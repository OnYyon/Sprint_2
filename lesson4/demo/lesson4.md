# Контекст
## Навигация
- [Контекст](#context)
- [Отмена контекста](#decline-context)
- [Передача значения в контексте](#get-value-in-context)
- [Когда использовать context.WithValue](#when-to-use)
- [Когда передавать context](#when-transfer)
## <a id="context"></a>Контекст
При разработке программ, которые требуют параллельных вычислений, часто приходится завершать выполняемые операции до того, как они окончатся сами. Для этого можно использовать отдельный канал и выходить из цикла обработки, когда этот канал будет закрыт (обсудим такой вариант подробнее в следующих уроках курса):

```go
// тело функции, из которой надо выйти
select {
	case <-done: // если канал закрыт
		return // выходим из функции
	default:
		// основные вычисления будут здесь
}
```
Было бы полезно, если бы мы могли передавать дополнительную информацию вместе с простым уведомлением об отмене — например, сообщать, есть ли у нашей функции срок (```deadline```), к которому она должна завершиться. Такая необходимость часто возникает при разработке систем, которые выполняют задачи параллельно. Чтобы упростить подобные задачи, авторы Go создали стандартный шаблон — пакет context, который мы рассматривали на предыдущих уроках.
## <a id="decline-context"></a> Отмена контекста
Представим, что у нас есть функция, которая получает данные из какого-либо источника:
```go
func readSource(ctx context.Context) error {
	// имитируем долгую работу функции
	time.Sleep(3 * time.Second)
	// допустим, возникла ошибка в процессе
	return fmt.Errorf("some error in readSource")
}
```
И другая функция, которая эти данные обрабатывает:
```go
func processSourceData(ctx context.Context) error {
	// получаем данные в цикле
	for {
		select {
		// раз в секунду получаем новые данные
		case <-time.After(time.Second):
			// здесь может быть код получения очередной порции данных
			fmt.Println("process data bit by bit...")
		// проверим контекст на отмену
		case <-ctx.Done():
			fmt.Println("processSourceData was canceled")
			return nil
		}
	}
}
```
Попробуем всё собрать вместе:
```go
func main(){
	ctx := context.Background()
	// ожидаем завершения горутин
	wg := sync.WaitGroup{}
	wg.Add(2)
	go func() {
		defer wg.Done()
		// запускаем функцию обработки данных
		if err := processSourceData(ctx); err != nil {
			fmt.Printf("processSourceData(ctx): %s", err)
		}
	}()
	go func() {
		defer wg.Done()
		// запускаем функцию чтения данных
		if err := readSource(ctx); err != nil {
			fmt.Printf("readSource(ctx): %s", err)
		}
	}()
	// ждём завершения
	wg.Wait()
}
```
Если вы запустите код, у вас получится примерно такой вывод:
```
process data bit by bit...
process data bit by bit...
process data bit by bit...
readSource(ctx): some error in readSource
process data bit by bit...
process data bit by bit...
...
```
То есть после того, как возникла ошибка в функции readSource, processSourceData продолжит ждать новые данные и никогда не завершится. Давайте попробуем это исправить и создадим контекст, который можно отменить:
```go
ctxWithCancel, cancelCtx := context.WithCancel(ctx)
```
Внесём изменения в функцию main:
```go
	// контекст, который можно отменить
	ctx := context.Background()
	ctxWithCancel, cancelCtx := context.WithCancel(ctx)
	defer cancelCtx()
	wg := sync.WaitGroup{}
	wg.Add(2)
	go func() {
		defer wg.Done()
		if err := processSourceData(ctxWithCancel); err != nil {
			fmt.Printf("processSourceData(ctxWithCancel): %s", err)
		}
	}()
	go func() {
		defer wg.Done()
		if err := readSource(ctxWithCancel); err != nil {
			// при ошибке в функции чтения подадим сигнал через контекст
			cancelCtx()
			fmt.Printf("readSource(ctxWithCancel): %s", err)
		}
	}()
	wg.Wait()
```
Теперь после вызова cancelCtx() функция processSourceData завершит выполнение, и программа тоже завершится.
# <a id="get-value-in-context"></a>Передача значения в контексте
При обработке запросов (например, на сервере) обычно требуется передавать какие-либо данные, специфичные для этого запроса, ниже по стеку. Например:
```go
func ProcessRequest(userID string) {
	// сохраним значение в контексте
	ctx := context.WithValue(context.Background(), "userID", userID)
	// функция обработки
	HandleResponse(ctx)
}
// здесь контекст уже содержит userID
func HandleResponse(ctx context.Context) {
	fmt.Printf("handling response for (%v)", ctx.Value("userID"))
}
```
Важно отметить, что значения, которые хранятся в определённом контексте, изменить нельзя (immutable). Когда мы вызываем context.WithValue, мы передаём родительский контекст и получаем контекст обратно, поскольку эта функция его не изменила. Вместо этого она завернула родительский контекст в другой с новым значением. Рассмотрим пример:
```go
// сохраним значение myValue по ключу myKey
ctx = context.WithValue(ctx, "myKey", "myValue")
fmt.Printf("my value is %s\n", ctx.Value("myKey")) // my value is myValue
// сохраним значение anotherValue по ключу myKey
anotherCtx := context.WithValue(ctx, "myKey", "anotherValue")
fmt.Printf("my value is %s\n", anotherCtx.Value("myKey")) // my value is anotherValue
```
Когда мы используем метод Value, он находит самое «внешнее» значение (из последнего контекста) для этого ключа и возвращает значение.

В простых программах допускается сохранять значения стандартных типов в контексте, однако это может привести к коллизиям. Давайте взглянем на такой код:
```go
func HandleResponse(ctx context.Context) { // допустим, переданный контекст содержит значение по ключу userID
	newUserID := "22"
	ctx = context.WithValue(ctx, "userID", newUserID) // запишем значение по ключу userID
	fmt.Printf("handling response for (%v)", ctx.Value("userID")) // handling response for 22
}
```
В рамках одного пакета такой ошибки можно избежать. А что если вы используете пакеты сторонних разработчиков? Чтобы предотвратить подобные ситуации в реальных системах, рекомендуем создавать отдельный тип данных для сохранения в контексте:
```go
// создадим тип данных для хранения id пользоваталя
type userID string
func ProcessRequest(id userID) {
	// сохраним значение в контексте
	ctx := context.WithValue(context.Background(), "userID", id)
}
```
Когда значение будет получено, достаточно будет проверить тип сохранённого объекта, чтобы убедиться, что он сохранён в рамках вашего пакета:
```go
id, ok := ctx.Value("userID").(userID)
if !ok{
	// другой тип объекта
}
```
Когда вы сохраняете значение в контекст, всегда помните, что оно может быть использовано в различных горутинах.

## <a id="when-to-use"></a>Когда использовать context.WithValue
Конечно, заманчиво поместить все ваши данные в контекст и использовать их в функциях вместо параметров, но такой код будет трудновато читать и поддерживать.

Обычно любые данные, необходимые для запуска функции, нужно передавать в качестве параметров. Иногда может быть полезно сохранять некоторые значения (например, имена пользователей), в значениях контекста. Но если имя пользователя используется для того, чтобы повлиять на результат работы функции (например, в конструкции ```if```), вам следует включить имя в качестве её параметра, даже если оно уже доступно из контекста.
## <a id="when-transfer"></a>Когда передавать context
Когда программы используют ```context``` и передают его от функции к функции, они также передают информацию от ```main``` до самого глубокого вызова в программе. Например, контекст при обработке http-запроса позволяет получить информацию о клиенте, который делает запрос, и завершить обработку, если клиент отключится до завершения запроса. Также с помощью ```http.TimeoutHandler``` можно ограничить время обработки запроса сервером (документация по теме <a href="https://pkg.go.dev/net/http#TimeoutHandler">здесь</a>).

Таким образом, если вы задумываетесь, использовать ли контекст или изобрести что-то другое для, например, отмены выполнения программы, лучше используйте контекст, это правило хорошего программистского тона.
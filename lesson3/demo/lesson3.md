# Мьютексы

## Кэширование данных
Программистам часто бывает нужно реализовать кэширование. Некоторые операции (например, дорогостоящие вычисления, операции ввода-вывода или работа с базами данных) выполняются медленно, поэтому кэшировать результаты имеет смысл после того, как они будут получены.

>**Кэш** — высокоскоростной уровень хранения, требуемый набор днных на котором, как правило, временный. Доступ к данным в кэше значительно быстрее, чем в основном месте их хранения (обычно в базе данных). С помощью кэширования можно эффективно повторно использовать ранее полученные или вычисленные данные.

Для этого создадим интерфейс, который описывает метод получения данных из базы:
```go
type DataRetriever interface {
	Retrieve(ID string) (*Data, error)
}
```
Создадим структуру для описания данных
```go
type Data struct {
	ID string // для упрощения содержит только ID
}
```
Теперь запрограммируем сам кэш:
```go
// кэш для хранения данных
type Cache struct {
	// данные будем хранить здесь
	m  map[string]*Data
	dr DataRetriever
}
// создаём новый объект
func NewCache(dr DataRetriever) *Cache {
	return &Cache{
		m:  make(map[string]*Data),
		dr: dr,
	}
}
```
Реализуем метод ```Get```, чтобы получать данные из кэша:
```go
func (c *Cache) Get(ID string) (Data, bool) {
	// проверим, есть ли данные в кэше
	data, exists := c.m[ID]
	// нашли в мапе — вернём значение
	if exists {
		return *data, true
	}
	// данные не нашли — нужно запросить
	data, err := c.dr.Retrieve(ID)
	if err != nil {
		// ошибка получения данных — запишем в лог
		log.Printf("c.dr.Retrieve(ID): %s", err)
		// вернём пустое значение
		return Data{}, false
	}
	// получили значение — запомним
	c.m[data.ID] = data
	// вернём полученное значение
	return *data, true
}
```
Это вполне рабочий вариант, но только если мы используем его в одной горутине. При чтении кэша и записи в него несколькими горутинами мы получим состояние гонки (race condition).

>В состоянии гонки (race condition) несколько потоков (или процессов) одновременно пытаются выполнить операции чтения и записи. Представьте: мы хотим посчитать какое-то значение, прибавить к нему 1, а потом перезаписать. Если эту операцию произвести в двух горутинах, которые работают параллельно, они одновременно считают старое значение, прибавят к нему 1, получат одинаковый результат, запишут его, и значение увеличится только на 1. Если бы состояния гонки не было, горутины отработали бы последовательно и прибавили к предыдущему результату 2.

Кэш обычно используется многими горутинами, поэтому он должен быть потокобезопасным. Для этого добавим мьютекс:
```go
import "sync"
// ...
type Cache struct {
   m  map[string]*Data
   dr DataRetriever
   mu sync.Mutex
}
```
Вызов mu.Lock() и mu.Unlock() будет определять, что находится в критической секции. Только после вызова Unlock() другая горутина сможет заблокировать мьютекс mu с помощью mu.Lock(). Внесём изменения в функцию Get:
```go
func (c *Cache) Get(ID string) (Data, bool) {
   c.mu.Lock()
   data, exists := c.m[ID] // теперь доступ к мапе внутри критической секции
   c.mu.Unlock()
   // нашли в мапе — вернём значение
   if exists {
   	return *data, true
   }
   // запрос данных из базы — не в критической секции
   data, err := c.dr.Retrieve(ID) 
   if err != nil {
   	// ошибка получения данных — запишем в лог
   	log.Printf("c.dr.Retrieve(ID): %s", err)
   	// вернём пустое значение
   	return Data{}, false
   } 
   // перед обращением к мапе снова заблокируем мьютекс
   c.mu.Lock()
   // разблокируем при выходе из функциии
   defer c.mu.Unlock()
   // внутри критической секции нужно снова проверить на наличие значения в мапе
   data, exists = c.m[data.ID]
   if exists {
   	return *data, true
   }
   // получили значение — запомним
   c.m[data.ID] = data
   // вернём полученное значение
   return *data, true
}
```
Обратите внимание: код получения объекта из базы данных находится вне критической секции. Таким образом другие горутины могут продолжать использовать кэш.

После того, как объект из базы получен, кэш снова блокируется, поскольку этот объект нужно поместить в мапу. После этого необходимо снова проверить, был ли объект уже помещён в кэш другой горутиной. Это возможно, поскольку несколько горутин могут одновременно запрашивать объект с помощью одного и того же идентификатора. Повторная проверка после блокировки позволит убедиться: если другая горутина уже поместила объект в кэш, он не будет перезаписан новой копией.

---
## RWMutex
В некоторых случаях, как в примере с кэшем, можно выделить два типа критических секций, для чтения и для записи. Мы можем предположить, что чтение объекта из мапы несколькими горутинами не нарушит её целостность, поэтому хорошо бы блокировать чтение только в момент записи другими горутинами. Для этого можно использовать RWMutex:
```go
type Cache struct {
	m  map[string]*Data
	dr DataRetriever
	mu sync.RWMutex
}
```
Давайте посмотрим, как изменится код Get:
```go
 func (c *Cache) Get(ID string) (Data, bool) {
	c.mu.RLock()
	// теперь в эту секцию могут зайти несколько горутин
	data, exists := c.m[ID] 
	c.mu.RUnlock()
	// далее без изменений
} 
```
Теперь код для получения объекта из мапы может выполняться из нескольких горутин. Когда понадобится внести изменения, будет вызван c.mu.Lock(), который не позволит читать данные из мапы до снятия блокировки c.mu.Unlock().

---
## Особенности использования
Мьютексы дают удобный механизм синхронизации, однако при работе с ними нужно учитывать ряд особенностей.
### Копирование мьютекса
Мьютексы не следует копировать. Когда вы делаете это, то получаете два мьютекса: оригинал и копию, и блокировка оригинала никак не связана с блокировкой копий. Поэтому, если вы объявите метод Get так, это приведёт к нежелательным последствиям:
```go
func (c Cache) Get(ID string) (Data, bool)
```
### Двойная блокировка
Мьютекс не отслеживает, какая горутина его заблокировала, поэтому двойная блокировка мьютекса из одной и той же горутины приведёт к её собственной блокировке. Это распространённая проблема с несколькими функциями, которые могут вызывать друг друга, а также блокировать один и тот же мьютекс:
```go
var m sync.Mutex

func first() {
	m.Lock()
	defer m.Unlock()
	second() // lock
}

func second() {
	m.Lock() // здесь будет вызов m.Lock() второй раз
	defer m.Unlock()
	// далее — основное тело функции 
}
```
В примере выше при вызове функции second() мы получим заблокированную горутину, потому что к этому моменту уже произошёл вызов m.Lock().
### Использование из нескольких горутин
Поскольку мьютекс не отслеживает, какая горутина его заблокировала, может получиться, что блокирует мьютекс одна горутина, а снимает блокировку другая. Такое использование мьютекса недопустимо и приводит к нежелательным результатам.
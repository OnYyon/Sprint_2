> В этом уроке мы познакомимся с таймерами и тайм-аутами из пакета time стандартной библиотеки Go.
# Таймеры
Golang предлагает множество функций, которые упрощают разработку конкурентных и сетевых программ. Таймеры — одна из таких функций, которая позволяет запланировать выполнение задачи на определённое время.

Структура Timer пакета time не начинает работать автоматически сразу после создания. Вместо этого она ожидает определённого момента времени и срабатывает однократно, запустить её повторно не получится.

Вот как выглядит структура Timer:
```go
// тип «таймер» представляет одно событие
// когда время до окончания работы таймера истекает, текущее время будет отправлено в канал C, если только таймер не был создан с помощью AfterFunc
// таймер должен быть создан с помощью NewTimer или AfterFunc
type Timer struct {
	C <-chan Time
	r runtimeTimer
}
```
Рассмотрим простой пример использования таймера:
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// создание таймера, время которого истечёт через 3 секунды
	timer := time.NewTimer(3 * time.Second)
	// канал C отправляет значение, которое указывает на окончание работы таймера
	<-timer.C
	fmt.Println("Time's up!")
}
```
В этом фрагменте кода мы создали новый таймер, время которого истечёт через 3 секунды. Функция main ждёт, когда будет получено значение из канала C таймера. Оно укажет на окончание его работы.

Но зачем нам таймеры, если мы можем просто подключить функцию time.Sleep() и ждать? Дело в том, что они могут быть остановлены в любое время до срабатывания.

Рассмотрим пример с остановкой таймера. Для этого расширим код из предыдущего примера:
```go
package main

import (
	"fmt"
	"time"
)

func timersStoppage(v time.Timer) {
	<-v.C
	fmt.Println("Второй таймер сработал")
}
func main() {
	// создание первого таймера
	timer := time.NewTimer(3 * time.Second)
	// в канал C отправляется значение, которое указывает на окончание работы таймера
	<-timer.C
	fmt.Println("Первый таймер сработал!")
	// создание второго таймера
	timer_s := time.NewTimer(time.Second)
	// создание горутины
	go timersStoppage(*timer_s)
	// удалите // из строки ниже, чтобы сработал второй таймер
	// timersStoppage((*timer_s))
	// остановка второго таймера перед срабатыванием
	stop_s := timer_s.Stop()
	if stop_s {
		fmt.Println("Второй таймер остановлен")
	}
}
```
В этом примере у второго таймера есть одна секунда на срабатывание, но мы остановили его, прежде чем он успел включиться. Если вы хотите увидеть, как сработает второй таймер, удалите // в начале строки `//timersStoppage((*timer_s))`.
## Тайм-ауты
Тайм-ауты ограничивают выполнение операции по времени.

В концепции параллелизма Go горутины выполняются одновременно, но за разные сроки. Если мы не хотим выводить результаты работы некоторых горутин после определённого периода времени, мы можем остановить их с помощью функции time.After. Посмотрим на её сигнатуру:
```go
func After(d Duration) <-chan Time
```
Вот как можно использовать тайм-аут:
```go
package main

import (
	"fmt"
	"time"
)


func timeoutTest() string {
	// уменьшаем время здесь, чтобы попасть в пределы
	time.Sleep(4 * time.Second)
	return "Функция TimeoutTest выполнена!"
}

func main() {
	// создание канала C
	c := make(chan string, 1)
	// создание потока выполнения горутины
	go func() {
		str := timeoutTest()
		c <- str
	}()
	// создание тайм-аута для выполнения функции
	select {
	case res := <-c:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("Время вышло!")
	}
}
```
В этом примере у нас есть функция TimeoutTest, которая занимает 4 секунды. Созданная горутина запишет строку в канал после 4 секунд. Теперь в секции select мы ограничили время до 3 секунд, создав тайм-аут, и время закончилось. Для вывода результата уменьшите время в функции time.Sleep(), чтобы оно было меньше установленного предела тайм-аута.